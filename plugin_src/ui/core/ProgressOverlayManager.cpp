/**
 * @file ProgressOverlayManager.cpp
 * @brief Implementation of thread-safe progress overlay manager
 */

#include "ProgressOverlayManager.h"
#include "SynapticUI.h"
#include <thread>
#include <chrono>

#ifdef _WIN32
  #include <windows.h>
#elif defined(__APPLE__)
  #include <CoreFoundation/CoreFoundation.h>
#endif

namespace synaptic {
namespace ui {

namespace {
  // Helper function to pump platform messages and ensure UI updates are painted
  // This is necessary for synchronous operations where we need UI feedback before blocking
  void PumpMessagesAndWaitForPaint()
  {
    #ifdef _WIN32
      MSG msg;
      // First pass: process any pending messages
      while (PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE))
      {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
      }
      // Give system time to paint
      Sleep(50);
      // Second pass: process any messages generated by paint
      while (PeekMessageW(&msg, NULL, 0, 0, PM_REMOVE))
      {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
      }
      // Final delay to ensure paint completes
      Sleep(50);
    #elif defined(__APPLE__)
      // On macOS, process events in the run loop to force UI updates
      // Run the event loop multiple times to ensure paint completes
      for (int i = 0; i < 3; i++)
      {
        // Process all pending events
        CFRunLoopRunInMode(kCFRunLoopDefaultMode, 0.05, true);
      }
      // Additional delay to ensure rendering completes
      std::this_thread::sleep_for(std::chrono::milliseconds(50));
    #else
      // On other platforms, just yield briefly
      std::this_thread::sleep_for(std::chrono::milliseconds(100));
    #endif
  }
} // anonymous namespace

void ProgressOverlayManager::Show(const std::string& title, const std::string& message, float progress, bool showCancelButton)
{
  // Queue for main thread processing
  std::lock_guard<std::mutex> lock(mMutex);
  mPendingUpdate.type = UpdateType::Show;
  mPendingUpdate.title = title;
  mPendingUpdate.message = message;
  mPendingUpdate.progress = progress;
  mPendingUpdate.showCancelButton = showCancelButton;
  mHasUpdate = true;
}

void ProgressOverlayManager::Update(const std::string& message, float progress)
{
  // Queue for main thread processing
  std::lock_guard<std::mutex> lock(mMutex);
  // Preserve Show type if pending, otherwise mark as Update
  if (mPendingUpdate.type != UpdateType::Show)
    mPendingUpdate.type = UpdateType::Update;
  mPendingUpdate.message = message;
  mPendingUpdate.progress = progress;
  mHasUpdate = true;
}

void ProgressOverlayManager::Hide()
{
  // Queue for main thread processing
  std::lock_guard<std::mutex> lock(mMutex);
  mPendingUpdate.type = UpdateType::Hide;
  mHasUpdate = true;
}

void ProgressOverlayManager::ProcessPendingUpdates(SynapticUI* ui)
{
  if (!ui || !mHasUpdate.exchange(false))
    return;

  // Copy pending update under lock
  PendingUpdate update;
  {
    std::lock_guard<std::mutex> lock(mMutex);
    update = mPendingUpdate;

    // After processing a Show, mark that we've shown the overlay
    // so subsequent Updates don't try to show again
    if (mPendingUpdate.type == UpdateType::Show)
    {
      mPendingUpdate.type = UpdateType::None;
    }
  }

  // Apply update on UI thread
  switch (update.type)
  {
      case UpdateType::Show:
        ui->ShowProgressOverlay(update.title, update.message, update.progress, update.showCancelButton);
        break;

    case UpdateType::Update:
      ui->UpdateProgressOverlay(update.message, update.progress);
      break;

    case UpdateType::Hide:
      ui->HideProgressOverlay();
      break;

    case UpdateType::None:
      break;
  }
}

void ProgressOverlayManager::ShowImmediate(const std::string& title, const std::string& message)
{
  if (mSynapticUI)
  {
    // Show immediately on current thread (must be main thread)
    mSynapticUI->ShowProgressOverlay(title, message, 0.0f, false);

    // Force the UI to update by marking all controls dirty
    if (auto* graphics = mSynapticUI->graphics())
    {
      graphics->SetAllControlsDirty();
    }

    // Pump messages to force the overlay to paint before returning
    PumpMessagesAndWaitForPaint();
  }
}

void ProgressOverlayManager::HideImmediate()
{
  if (mSynapticUI)
  {
    // Hide immediately on current thread (must be main thread)
    mSynapticUI->HideProgressOverlay();
  }
}

} // namespace ui
} // namespace synaptic

