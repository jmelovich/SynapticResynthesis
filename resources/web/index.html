<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style type="text/css">
    * {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    p, h1 {
      pointer-events: none;
    }

    body {
      overflow: auto;
      padding: 0 20px;
      -webkit-overflow-scrolling: touch;
      background-color: #ffffff;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    /* Unused layout classes - commented out to prevent interference
    .left {
      width: 50%;
      position: absolute;
      left: 0;
      display: table-cell;
      vertical-align: middle;
    }

    .left span, .left input {
      vertical-align: middle;
    }

    .right {
      width: 50%;
      position: absolute;
      right: 0;
      display: table-cell;
      vertical-align: middle;
    }

    .right span {
      vertical-align: middle;
    }

    .right input {
      vertical-align: baseline;
    }
    */

    button {
      display: block;
    }

    .dropzone {
        border: 4px dashed #d1d5db;
        border-radius: 0.5rem;
        text-align: center;
        background-color: #f3f4f6;
        transition: all 0.2s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }

    .dropzone.dragover {
        border-color: #3b82f6;
        background-color: #eff6ff;
    }

    .dropzone.has-file {
        background-color: #f0fdf4;
    }

    .icon {
        width: 3rem;
        height: 3rem;
        margin-bottom: 0.5rem;
    }

    .filename {
        font-size: 1.125rem;
        font-weight: 600;
        color: #374151;
        margin: 0.5rem 0;
    }

    .filesize {
        font-size: 0.875rem;
        color: #6b7280;
        margin-bottom: 1rem;
    }

    .file-content {
        cursor: move;
        user-select: none;
    }

    .drag-instructions {
        font-size: 0.875rem;
        color: #4b5563;
        margin-top: 1rem;
    }

    /* Drag image styles */
    .drag-image {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: white;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        max-width: 300px;
        position: fixed;
        left: -9999px;
        top: -9999px;
    }

    .drag-image .file-icon {
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #4f46e5;
        border-radius: 6px;
        padding: 6px;
    }

    .drag-image .file-icon svg {
        width: 20px;
        height: 20px;
        color: white;
    }

    .drag-image .file-info {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 2px;
    }

    .drag-image .file-name {
        font-weight: 500;
        color: #1f2937;
        font-size: 14px;
    }

    .drag-image .file-type {
        color: #6b7280;
        font-size: 12px;
    }

    .controls-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .param-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 8px;
    }

    .input-group .param-list {
      margin-top: 8px;
      margin-bottom: 0;
    }
    .reanalysis-box {
      border: 2px dashed #f59e0b;
      background: #fffbeb;
      border-radius: 8px;
      padding: 10px;
      margin-top: 8px;
    }
    .reanalysis-box .hint {
      color: #92400e;
      font-size: 12px;
      margin-bottom: 8px;
    }
    .param-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .param-row label {
      width: 180px;
      color: #374151;
      font-size: 14px;
    }
    .param-row input[type="range"] { flex: 1; }
    .param-row .value { width: 70px; text-align: right; color: #374151; font-size: 13px; }

    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-start;
    }

    .links-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-start;
    }

    .link-button {
      text-decoration: none;
    }

    .file-input-group {
      margin-top: 10px;
    }

    input[type="file"] {
      padding: 10px;
      border: 2px solid #d1d5db;
      border-radius: 6px;
      /* width: 100%; */
    }

    button-control,
    knob-control {
      font-family: inherit;
    }
    .tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 12px;
    }
    .tab-button {
      background-color: #f3f4f6;
      border: 2px solid #d1d5db;
      border-radius: 6px;
      color: #374151;
      cursor: pointer;
      font-family: inherit;
      font-size: 14px;
      font-weight: 500;
      padding: 6px 12px;
    }
    .tab-button.active {
      background-color: #e5e7eb;
      border-color: #9ca3af;
    }
    #brain-section { display: none; }
    .brain-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      margin-top: 12px;
      max-height: 200px;
      overflow-y: auto;
      padding: 6px;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      background-color: #fafafa;
    }
    .brain-list-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 8px 10px;
    }
    .remove-btn {
      background-color: #ef4444;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      padding: 4px 8px;
      font-weight: 600;
    }
    .overlay {
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }
    .overlay.global { position: fixed; }
    .spinner {
      width: 24px;
      height: 24px;
      border: 3px solid #cbd5e1;
      border-top-color: #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    .overlay-text { margin-top: 8px; color: #374151; font-size: 13px; }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>

  <script src="script.js"></script>
  <script type="module" src="knob-control.js"></script>
  <script type="module" src="button-control.js"></script>
  <script>
    function switchTab(which) {
      const dspBtn = document.getElementById('tab-dsp-btn');
      const brainBtn = document.getElementById('tab-brain-btn');
      const dsp = document.getElementById('dsp-section');
      const brain = document.getElementById('brain-section');
      if (which === 'brain') {
        dsp.style.display = 'none';
        brain.style.display = 'block';
        dspBtn.classList.remove('active');
        brainBtn.classList.add('active');
      } else {
        dsp.style.display = 'block';
        brain.style.display = 'none';
        brainBtn.classList.remove('active');
        dspBtn.classList.add('active');
      }
      // Resize window to fit new content after tab switch
      setTimeout(resizeWindowToFit, 100);
    }
    function SendTestBinaryData() {
      let uint8 = new Uint8Array([0, 0, 0, 0]);
      uint8.fill(4, 1, 3);
      var bin = String.fromCharCode.apply(null, uint8);
      SAMFUI(3, -1, window.btoa(bin));
    }

    function SendTestMIDIData() {
      SMMFUI(0x90, 60, 0x7f);
      setTimeout(function(){
        SMMFUI(0x90, 60, 0x00);
      }, 1000);
    }

    function OnParamChange(param, value) {
      // Handle overlap checkbox (paramIdx=7)
      if (param == 7) {
        const checkbox = document.getElementById('enableOverlap');
        if (checkbox) {
          checkbox.checked = value > 0.5;
        }
        return;
      }

      // Handle AGC checkbox (paramIdx=9)
      if (param == 9) {
        const checkbox = document.getElementById('enableAGC');
        if (checkbox) {
          checkbox.checked = value > 0.5;
        }
        return;
      }

      // Handle morph mode dropdown (paramIdx=10)
      if (param == 10) {
        const select = document.getElementById('morphMode');
        if (select) {
          // Convert normalized value back to enum index (0-5)
          const enumValue = Math.round(value * 5.0);
          select.value = enumValue;
          updateMorphParams(enumValue);
        }
        return;
      }

      // Handle morph amount (paramIdx=11)
      if (param == 11) {
        const input = document.getElementById('morphAmount');
        if (input) {
          input.value = value;
          const valueEl = input.parentNode.querySelector('.value');
          if (valueEl) valueEl.textContent = (Number(value)).toFixed(2);
        }
        return;
      }

      // Handle phase morph amount (paramIdx=12)
      if (param == 12) {
        const input = document.getElementById('phaseMorphAmount');
        if (input) {
          input.value = value;
          const valueEl = input.parentNode.querySelector('.value');
          if (valueEl) valueEl.textContent = (Number(value)).toFixed(2);
        }
        return;
      }

      // Handle vocoder sensitivity (paramIdx=13)
      if (param == 13) {
        const input = document.getElementById('vocoderSensitivity');
        if (input) {
          input.value = value;
          const valueEl = input.parentNode.querySelector('.value');
          if (valueEl) valueEl.textContent = (Number(value)).toFixed(2);
        }
        return;
      }

      // Find the knob control with matching param-id
      const knob = document.querySelector(`knob-control[param-id="${param}"]`);
      if (knob) {
        // Pass the normalized value directly to the knob
        knob.updateValueFromHost(value);
      }
    }

    function OnControlChange(ctrlTag, value) {
    }

    // This fires when the C++ side sends a message to the UI.
    function OnMessage(msgTag, dataSize, data) {
      if (msgTag == -1 && dataSize > 0) {

      let json = JSON.parse(window.atob(data));

      switch (json["id"])
      {
        case "params":
          window["parameters"] = json["params"];

          const allElements = document.querySelectorAll('*');

          allElements.forEach(element => {
            if (element.tagName == "KNOB-CONTROL") {
              const paramInfo = json["params"][element.paramId];
              element.setAttribute("min", paramInfo["min"]);
              element.setAttribute("max", paramInfo["max"]);
              element.setAttribute("label", paramInfo["name"]);
              element.setAttribute("default-value", paramInfo["default"]);
            }
          });

          break;
        case "brainSummary":
          updateBrainList(json["files"] || []);
          hideGlobalOverlay();
          break;
        case "dspConfig": {
          const cs = document.getElementById('chunkSize');
          const ow = document.getElementById('outputWindow');
          const aw = document.getElementById('analysisWindow');
          const alg = document.getElementById('algorithm');
          if (alg && Array.isArray(json["algorithms"])) {
            alg.innerHTML = '';
            json["algorithms"].forEach(item => {
              const o = document.createElement('option');
              o.value = String(item.index);
              o.textContent = item.label || item.id || String(item.index);
              alg.appendChild(o);
            });
          }
          if (cs && typeof json["chunkSize"] === 'number') cs.value = json["chunkSize"];
          if (ow && typeof json["outputWindowMode"] === 'number') ow.value = String(json["outputWindowMode"]);
          if (aw && typeof json["analysisWindowMode"] === 'number') aw.value = String(json["analysisWindowMode"]);
          if (alg && json["algorithmId"] !== undefined) alg.value = String(json["algorithmId"]);
          const bcs = document.getElementById('brain-chunk-size');
          if (bcs && typeof json["chunkSize"] === 'number') bcs.textContent = String(json["chunkSize"]);
          const storageEl = document.getElementById('brain-external-ref');
          if (storageEl) {
            const isExt = !!json["useExternalBrain"]; const p = json["externalPath"] || '';
            storageEl.textContent = isExt && p ? String(p) : '(inline)';
          }
          break;
        }
        case "brainChunkSize":
          const el = document.getElementById('brain-chunk-size');
          if (el) el.textContent = String(json["size"] ?? '-');
          break;
        case "brainRechunking":
          showGlobalOverlay();
          break;
        case "overlay": {
          const visible = !!json["visible"];
          const text = json["text"] ?? '';
          if (visible) showGlobalOverlay(text); else hideGlobalOverlay();
          break;
        }
        case "transformerParams":
          renderTransformerParams(json["params"] || []);
          break;
        case "brainExternalRef": {
          const info = json["info"] || {};
          const el = document.getElementById('brain-external-ref');
          if (el) el.textContent = info.path ? (String(info.path)) : '(inline)';
          break;
        }
        }
      }
    }

    function updateBrainList(files) {
      const list = document.getElementById('brain-files');
      if (!list) return;
      list.innerHTML = '';
      const countEl = document.getElementById('brain-file-count');
      if (countEl) countEl.textContent = String((files && files.length) ? files.length : 0);
      files.forEach(f => {
        const row = document.createElement('div');
        row.className = 'brain-list-item';
        const left = document.createElement('div');
        left.textContent = `${f.name} (${f.chunks})`;
        const btn = document.createElement('button');
        btn.className = 'remove-btn';
        btn.textContent = 'X';
        btn.onclick = () => {
          if (typeof window['SAMFUI'] === 'function') {
            window['SAMFUI'](101, f.id);
          }
        };
        row.appendChild(left);
        row.appendChild(btn);
        list.appendChild(row);
      });
    }
  </script>
</head>
<body>
<div class="tabs">
  <button id="tab-dsp-btn" class="tab-button active" onclick="switchTab('dsp')">DSP</button>
  <button id="tab-brain-btn" class="tab-button" onclick="switchTab('brain')">Brain</button>
  </div>
<h1>Synaptic Resynthesis</h1>
<div id="dsp-section" class="controls-container">
  <div class="input-container">
    <div class="reanalysis-box">
      <div class="hint">Changing these settings will cause the Brain to reanalyze its chunks.</div>
      <div class="input-group">
        <label for="chunkSize">Chunk Size</label>
        <input type="number" id="chunkSize" min="1" step="1" value="4096" />
      </div>
      <div class="input-group">
        <label for="analysisWindow">Chunk Analysis Window</label>
        <select id="analysisWindow">
          <option value="1" selected>Hann</option>
          <option value="2">Hamming</option>
          <option value="3">Blackman</option>
          <option value="4">Rectangular</option>
        </select>
      </div>
    </div>
    <div class="input-group">
      <label for="outputWindow">Output Window Function</label>
      <select id="outputWindow">
        <option value="1" selected>Hann</option>
        <option value="2">Hamming</option>
        <option value="3">Blackman</option>
        <option value="4">Rectangular</option>
      </select>
    </div>
    <div class="input-group">
      <label for="enableOverlap">Enable Overlap-Add Windowing</label>
      <input type="checkbox" id="enableOverlap" checked />
    </div>
    <div class="input-group">
      <label for="enableAGC">AGC (Auto Gain Control)</label>
      <input type="checkbox" id="enableAGC" />
    </div>
    <div class="input-group">
      <label for="algorithm">Transformer</label>
      <select id="algorithm">
        <option value="0" selected>Passthrough</option>
        <option value="1">Simple Sine Match</option>
        <option value="2">Simple SampleBrain</option>
      </select>
      <div id="transformer-params" class="param-list"></div>
    </div>
    <div class="input-group">
      <label for="morphMode">Morph Mode</label>
      <select id="morphMode">
        <option value="0" selected>None</option>
        <option value="1">Cross Synthesis</option>
        <option value="2">Spectral Vocoder</option>
        <option value="3">Cepstral Morph</option>
        <option value="4">Harmonic Morph</option>
        <option value="5">Spectral Masking</option>
      </select>
      <div id="morph-params" class="param-list"></div>
    </div>
  </div>


  <div id="dropzone" class="dropzone">
    <div id="file-content" class="file-content" style="display: none;" draggable="true">

    </div>
  </div>
  <div class="knob-container">
    <knob-control label="Input Gain" param-id=0></knob-control>
    <knob-control label="Output Gain" param-id=8></knob-control>
  </div>
</div>

<div id="brain-section" class="controls-container" style="position: relative;">
  <div id="brain-overlay" class="overlay"><div class="spinner"></div></div>
  <div id="brain-dropzone" class="dropzone" style="height: 140px;">
    <p class="instructions">Drag and drop audio files (wav, mp3, flac) to add to Brain</p>
  </div>
  <div style="margin-top:6px; color:#374151; font-size:13px;">
    Brain chunk size: <span id="brain-chunk-size">-</span>
    &nbsp;•&nbsp; Files: <span id="brain-file-count">0</span>
    &nbsp;•&nbsp; Storage: <span id="brain-external-ref">(inline)</span>
  </div>
  <div id="brain-files" class="brain-list"></div>
  <p style="color:#6b7280; font-size:12px;">Note: Chunk size currently set by DSP section and used for import.</p>
  <div class="button-group" style="margin-top:6px;">
    <button id="export-brain-btn">Export Brain (.sbrain)</button>
    <button id="import-brain-btn">Import Brain (.sbrain)</button>
    <button id="reset-brain-btn">Reset Brain</button>
    <button id="detach-brain-btn">Detach File Ref</button>
  </div>
</div>

<script>
    let currentFile = null;
    const dropzone = document.getElementById('dropzone');
    const initialContent = document.getElementById('initial-content');
    const fileContent = document.getElementById('file-content');
    const filename = document.getElementById('filename');
    const filesize = document.getElementById('filesize');

    // Prevent default drag behaviors
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, preventDefaults, false);
        document.body.addEventListener(eventName, preventDefaults, false);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    // Highlight dropzone when dragging over it
    ['dragenter', 'dragover'].forEach(eventName => {
        dropzone.addEventListener(eventName, highlight, false);
    });

    ['dragleave', 'drop'].forEach(eventName => {
        dropzone.addEventListener(eventName, unhighlight, false);
    });

    function highlight(e) {
        dropzone.classList.add('dragover');
    }

    function unhighlight(e) {
        dropzone.classList.remove('dragover');
    }

    // Handle dropped files
    dropzone.addEventListener('drop', handleDrop, false);

    function handleDrop(e) {
        const dt = e.dataTransfer;
        const file = dt.files[0];

        if (file && file.type === 'audio/x-wav') {
            handleFile(file);
        } else {
            alert('Please drop a WAV file');
        }
    }

    function handleFile(file) {
        currentFile = file;
        dropzone.classList.add('has-file');
        initialContent.style.display = 'none';
        fileContent.style.display = 'block';
        filename.textContent = file.name;
        filesize.textContent = `${(file.size / (1024 * 1024)).toFixed(2)} MB`;
    }

    // Handle drag start for file download
    fileContent.addEventListener('dragstart', handleDragStart, false);

    function handleDragStart(e) {
        if (!currentFile) return;

        // Set the drag data
        e.dataTransfer.setData('application/x-moz-file', currentFile); // For Firefox
        e.dataTransfer.setData('application/octet-stream', currentFile); // For other browsers

        // Create a new File object to ensure proper file transfer
        const fileTransfer = new File([currentFile], currentFile.name, {
            type: currentFile.type,
            lastModified: currentFile.lastModified
        });

        // Add the file to the data transfer
        e.dataTransfer.items.add(fileTransfer);

        // Set the drag image (existing code)
        e.dataTransfer.setDragImage(icon, 40, 35);
        e.dataTransfer.effectAllowed = 'copyMove';
    }

    // Integer inputs -> send to plugin via ctrlTag (no binary payload)
    const chunkSizeInput = document.getElementById('chunkSize');
    const bufferWindowSizeInput = document.getElementById('bufferWindowSize');
    const outputWindowSelect = document.getElementById('outputWindow');
    const analysisWindowSelect = document.getElementById('analysisWindow');
    const algorithmSelect = document.getElementById('algorithm');
    const morphModeSelect = document.getElementById('morphMode');

    function sanitizeInt(value, fallback, minVal = 1) {
      const n = parseInt(value, 10);
      if (isNaN(n)) return fallback;
      return Math.max(minVal, n);
    }

    function sendChunkSize(value) {
      if (typeof window['SAMFUI'] === 'function') {
        window['SAMFUI'](4, value);
      }
    }

    function sendOutputWindowMode(value) {
      if (typeof window['SAMFUI'] === 'function') {
        window['SAMFUI'](7, value);
      }
    }

    function sendAnalysisWindowMode(value) {
      if (typeof window['SAMFUI'] === 'function') {
        window['SAMFUI'](8, value);
      }
    }

    function sendAlgorithm(value) {
      if (typeof window['SAMFUI'] === 'function') {
        window['SAMFUI'](6, value);
      }
    }

    function sendMorphMode(value) {
      if (typeof window['SPVFUI'] === 'function') {
        // Normalize enum value to 0.0-1.0 range (6 possible values: 0-5)
        const normalizedValue = value / 5.0;
        window['SPVFUI'](10, normalizedValue); // paramIdx=10 for kMorphMode
      }
    }

    const onChunkChange = (e) => {
      const v = sanitizeInt(e.target.value, 4096, 1);
      e.target.value = v;
      sendChunkSize(v);
    };

    const onOutputWindowChange = (e) => {
      const v = parseInt(e.target.value, 10) || 1;
      sendOutputWindowMode(v);
    };

    const onAnalysisWindowChange = (e) => {
      const v = parseInt(e.target.value, 10) || 1;
      sendAnalysisWindowMode(v);
    };

    const onAlgorithmChange = (e) => {
      const v = parseInt(e.target.value, 10) || 0;
      sendAlgorithm(v);
    };

    const onMorphModeChange = (e) => {
      const v = parseInt(e.target.value, 10) || 0;
      sendMorphMode(v);
      updateMorphParams(v);
    };

    function updateMorphParams(mode) {
      const container = document.getElementById('morph-params');
      if (!container) return;
      
      container.innerHTML = '';
      
      if (mode === 0) return; // None mode - no additional controls
      
      // Cross Synthesis mode (mode === 1) - show morph amount and phase morph amount
      if (mode === 1) {
        // Add morph amount control
        const morphAmountRow = document.createElement('div');
        morphAmountRow.className = 'param-row';
        const morphAmountLabel = document.createElement('label');
        morphAmountLabel.textContent = 'Morph Amount';
        morphAmountRow.appendChild(morphAmountLabel);
        
        const morphAmountInput = document.createElement('input');
        morphAmountInput.type = 'range';
        morphAmountInput.min = '0';
        morphAmountInput.max = '1';
        morphAmountInput.step = '0.01';
        morphAmountInput.value = '1.0';
        morphAmountInput.id = 'morphAmount';
        
        const morphAmountValue = document.createElement('div');
        morphAmountValue.className = 'value';
        morphAmountValue.textContent = '1.00';
        
        morphAmountInput.addEventListener('input', () => {
          morphAmountValue.textContent = (Number(morphAmountInput.value)).toFixed(2);
        });
        
        morphAmountInput.addEventListener('change', () => {
          if (typeof window['SPVFUI'] === 'function') {
            window['SPVFUI'](11, Number(morphAmountInput.value)); // paramIdx=11 for kMorphAmount
          }
        });
        
        morphAmountRow.appendChild(morphAmountInput);
        morphAmountRow.appendChild(morphAmountValue);
        container.appendChild(morphAmountRow);
        
        // Add phase morph amount control
        const phaseMorphRow = document.createElement('div');
        phaseMorphRow.className = 'param-row';
        const phaseMorphLabel = document.createElement('label');
        phaseMorphLabel.textContent = 'Phase Morph Amount';
        phaseMorphRow.appendChild(phaseMorphLabel);
        
        const phaseMorphInput = document.createElement('input');
        phaseMorphInput.type = 'range';
        phaseMorphInput.min = '0';
        phaseMorphInput.max = '1';
        phaseMorphInput.step = '0.01';
        phaseMorphInput.value = '1.0';
        phaseMorphInput.id = 'phaseMorphAmount';
        
        const phaseMorphValue = document.createElement('div');
        phaseMorphValue.className = 'value';
        phaseMorphValue.textContent = '1.00';
        
        phaseMorphInput.addEventListener('input', () => {
          phaseMorphValue.textContent = (Number(phaseMorphInput.value)).toFixed(2);
        });
        
        phaseMorphInput.addEventListener('change', () => {
          if (typeof window['SPVFUI'] === 'function') {
            window['SPVFUI'](12, Number(phaseMorphInput.value)); // paramIdx=12 for kPhaseMorphAmount
          }
        });
        
        phaseMorphRow.appendChild(phaseMorphInput);
        phaseMorphRow.appendChild(phaseMorphValue);
        container.appendChild(phaseMorphRow);
      }
      
      // Spectral Vocoder mode (mode === 2) - show only vocoder sensitivity
      if (mode === 2) {
        const vocoderRow = document.createElement('div');
        vocoderRow.className = 'param-row';
        const vocoderLabel = document.createElement('label');
        vocoderLabel.textContent = 'Vocoder Sensitivity';
        vocoderRow.appendChild(vocoderLabel);
        
        const vocoderInput = document.createElement('input');
        vocoderInput.type = 'range';
        vocoderInput.min = '0';
        vocoderInput.max = '1';
        vocoderInput.step = '0.01';
        vocoderInput.value = '1.0';
        vocoderInput.id = 'vocoderSensitivity';
        
        const vocoderValue = document.createElement('div');
        vocoderValue.className = 'value';
        vocoderValue.textContent = '1.00';
        
        vocoderInput.addEventListener('input', () => {
          vocoderValue.textContent = (Number(vocoderInput.value)).toFixed(2);
        });
        
        vocoderInput.addEventListener('change', () => {
          if (typeof window['SPVFUI'] === 'function') {
            window['SPVFUI'](13, Number(vocoderInput.value)); // paramIdx=13 for kVocoderSensitivity
          }
        });
        
        vocoderRow.appendChild(vocoderInput);
        vocoderRow.appendChild(vocoderValue);
        container.appendChild(vocoderRow);
      }
      
      // Other modes (3, 4, 5) - no additional controls
      
      // Only resize when morph controls are added/removed
      if (mode === 1 || mode === 2) {
        setTimeout(resizeWindowToFit, 100);
      }
    }

    if (chunkSizeInput) {
      chunkSizeInput.addEventListener('change', onChunkChange);
    }

    if (outputWindowSelect) {
      outputWindowSelect.addEventListener('change', onOutputWindowChange);
    }

    if (analysisWindowSelect) {
      analysisWindowSelect.addEventListener('change', onAnalysisWindowChange);
    }

    if (algorithmSelect) {
      algorithmSelect.addEventListener('change', onAlgorithmChange);
    }

    if (morphModeSelect) {
      morphModeSelect.addEventListener('change', onMorphModeChange);
    }

    // Enable Overlap-Add checkbox
    const enableOverlapCheckbox = document.getElementById('enableOverlap');
    if (enableOverlapCheckbox) {
      enableOverlapCheckbox.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        if (typeof window['SPVFUI'] === 'function') {
          window['SPVFUI'](7, isChecked ? 1.0 : 0.0); // paramIdx=7 for EnableOverlap
        }
      });
    }

    // Enable AGC checkbox
    const enableAGCCheckbox = document.getElementById('enableAGC');
    if (enableAGCCheckbox) {
      enableAGCCheckbox.addEventListener('change', (e) => {
        const isChecked = e.target.checked;
        if (typeof window['SPVFUI'] === 'function') {
          window['SPVFUI'](9, isChecked ? 1.0 : 0.0); // paramIdx=9 for AGC
        }
      });
    }

    // Generic transformer params UI rendering and messaging
    function uint8ToBase64(uint8) {
      let binary = '';
      const chunkSize = 0x8000; // 32KB chunks
      for (let i = 0; i < uint8.length; i += chunkSize) {
        const chunk = uint8.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return window.btoa(binary);
    }

    function sendTransformerParamUpdate(id, type, value) {
      const obj = { id, type, value };
      const enc = new TextEncoder();
      const bytes = enc.encode(JSON.stringify(obj));
      const b64 = uint8ToBase64(bytes);
      if (typeof window['SAMFUI'] === 'function') {
        window['SAMFUI'](102, -1, b64);
      }
    }

    let resizeTimeout = null;
    let lastContentHeight = 0;
    
    function resizeWindowToFit() {
      // Debounce resize calls to prevent excessive resizing
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      
      resizeTimeout = setTimeout(() => {
        // Use requestAnimationFrame to ensure DOM has settled and measurements are accurate
        requestAnimationFrame(() => {
          const body = document.body;
          
          // Calculate content height more reliably
          let contentHeight = Math.max(
            body.scrollHeight,
            body.offsetHeight,
            document.documentElement.scrollHeight
          );
          
          // Add small margin for safety
          contentHeight = Math.ceil(contentHeight) + 10;
          
          // Only resize if the content height has actually changed significantly
          if (Math.abs(contentHeight - lastContentHeight) > 20) {
            lastContentHeight = contentHeight;
            
            // Get current width (preserve it)
            const currentWidth = window.innerWidth || 1024;

            // Send resize message to C++ - use measured content height
            const obj = { width: currentWidth, height: contentHeight };
            const enc = new TextEncoder();
            const bytes = enc.encode(JSON.stringify(obj));
            const b64 = uint8ToBase64(bytes);
            if (typeof window['SAMFUI'] === 'function') {
              window['SAMFUI'](108, -1, b64);
            }
          }
        });
      }, 150); // Increased debounce time
    }

    function renderTransformerParams(params) {
      const container = document.getElementById('transformer-params');
      if (!container) return;
      container.innerHTML = '';
      params.forEach(p => {
        const row = document.createElement('div');
        row.className = 'param-row';
        const label = document.createElement('label');
        label.textContent = p.label || p.id;
        row.appendChild(label);

        const type = p.type || 'number';
        const control = p.control || 'numberbox';
        const value = p.value;

        if (control === 'slider') {
          const input = document.createElement('input');
          input.type = 'range';
          input.min = (p.min ?? 0);
          input.max = (p.max ?? 1);
          input.step = (p.step ?? 0.01);
          input.value = value;
          const valEl = document.createElement('div');
          valEl.className = 'value';
          valEl.textContent = (Number(value)).toFixed(2);
          input.addEventListener('input', () => {
            valEl.textContent = (Number(input.value)).toFixed(2);
          });
          input.addEventListener('change', () => {
            sendTransformerParamUpdate(p.id, 'number', Number(input.value));
          });
          row.appendChild(input);
          row.appendChild(valEl);
        } else if (control === 'numberbox') {
          const input = document.createElement('input');
          input.type = 'number';
          if (p.min !== undefined) input.min = p.min;
          if (p.max !== undefined) input.max = p.max;
          if (p.step !== undefined) input.step = p.step;
          input.value = value;
          input.addEventListener('change', () => {
            sendTransformerParamUpdate(p.id, 'number', Number(input.value));
          });
          row.appendChild(input);
        } else if (control === 'checkbox') {
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.checked = !!value;
          input.addEventListener('change', () => {
            sendTransformerParamUpdate(p.id, 'boolean', !!input.checked);
          });
          row.appendChild(input);
        } else if (control === 'select') {
          const select = document.createElement('select');
          const opts = Array.isArray(p.options) ? p.options : [];
          opts.forEach(opt => {
            const o = document.createElement('option');
            o.value = String(opt.value);
            o.textContent = opt.label || String(opt.value);
            if (String(value) === String(opt.value)) o.selected = true;
            select.appendChild(o);
          });
          select.addEventListener('change', () => {
            sendTransformerParamUpdate(p.id, 'enum', select.value);
          });
          row.appendChild(select);
        } else if (control === 'textbox') {
          const input = document.createElement('input');
          input.type = 'text';
          input.value = value ?? '';
          input.addEventListener('change', () => {
            sendTransformerParamUpdate(p.id, (type === 'text' ? 'text' : 'string'), String(input.value));
          });
          row.appendChild(input);
        }

        container.appendChild(row);
      });

      // Only resize if we actually added transformer parameters
      if (params.length > 0) {
        setTimeout(resizeWindowToFit, 100);
      }
    }

    // Brain drop handling
    const brainDrop = document.getElementById('brain-dropzone');
    const brainChunkSizeEl = document.getElementById('brain-chunk-size');
    const globalOverlay = document.createElement('div');
    globalOverlay.className = 'overlay global';
    globalOverlay.style.display = 'none';
    const spinnerWrap = document.createElement('div');
    spinnerWrap.style.display = 'flex';
    spinnerWrap.style.flexDirection = 'column';
    spinnerWrap.style.alignItems = 'center';
    const spinnerEl = document.createElement('div');
    spinnerEl.className = 'spinner';
    const textEl = document.createElement('div');
    textEl.className = 'overlay-text';
    textEl.textContent = '';
    spinnerWrap.appendChild(spinnerEl);
    spinnerWrap.appendChild(textEl);
    globalOverlay.appendChild(spinnerWrap);
    document.body.appendChild(globalOverlay);
    function showGlobalOverlay(text){ if (globalOverlay) { globalOverlay.style.display='flex'; if (text !== undefined) textEl.textContent = String(text); } }
    function hideGlobalOverlay(){ if (globalOverlay) globalOverlay.style.display='none'; }
    if (brainDrop) {
      function uint8ToBase64(uint8) {
        let binary = '';
        const chunkSize = 0x8000; // 32KB chunks
        for (let i = 0; i < uint8.length; i += chunkSize) {
          const chunk = uint8.subarray(i, i + chunkSize);
          binary += String.fromCharCode.apply(null, chunk);
        }
        return window.btoa(binary);
      }
      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(evt => {
        brainDrop.addEventListener(evt, (e) => { e.preventDefault(); e.stopPropagation(); }, false);
      });
      ['dragenter', 'dragover'].forEach(evt => brainDrop.addEventListener(evt, () => brainDrop.classList.add('dragover')));
      ;['dragleave', 'drop'].forEach(evt => brainDrop.addEventListener(evt, () => brainDrop.classList.remove('dragover')));
      brainDrop.addEventListener('drop', async (e) => {
        const files = e.dataTransfer.files;
        if (!files || files.length === 0) return;
        showGlobalOverlay();
        for (let i = 0; i < files.length; ++i) {
          const f = files[i];
          if (!/^audio\//.test(f.type) && !/\.(wav|wave|flac|mp3)$/i.test(f.name)) continue;
          const arrayBuf = await f.arrayBuffer();
          // Build header: uint16 LE nameLen + name bytes + file data
          const enc = new TextEncoder();
          const nameBytes = enc.encode(f.name);
          const header = new Uint8Array(2 + nameBytes.length + arrayBuf.byteLength);
          header[0] = nameBytes.length & 0xFF;
          header[1] = (nameBytes.length >> 8) & 0xFF;
          header.set(nameBytes, 2);
          header.set(new Uint8Array(arrayBuf), 2 + nameBytes.length);
          const b64 = uint8ToBase64(header);
          if (typeof window['SAMFUI'] === 'function') {
            window['SAMFUI'](100, -1, b64);
          }
        }
      });
    }

    // Export/Import buttons
    const exportBtn = document.getElementById('export-brain-btn');
    const importBtn = document.getElementById('import-brain-btn');
    if (exportBtn) {
      exportBtn.addEventListener('click', () => {
        if (typeof window['SAMFUI'] === 'function') window['SAMFUI'](104, -1);
      });
    }
    if (importBtn) {
      importBtn.addEventListener('click', async () => {
        if (typeof window['SAMFUI'] === 'function') {
          // C++ side will show overlay and native Open File dialog, then load
          window['SAMFUI'](105, -1);
        }
      });
    }

    // Reset and Detach
    const resetBtn = document.getElementById('reset-brain-btn');
    if (resetBtn) resetBtn.addEventListener('click', () => { if (typeof window['SAMFUI'] === 'function') window['SAMFUI'](106, -1); });
    const detachBtn = document.getElementById('detach-brain-btn');
    if (detachBtn) detachBtn.addEventListener('click', () => { if (typeof window['SAMFUI'] === 'function') window['SAMFUI'](107, -1); });

    // Initial resize to fit content
    window.addEventListener('load', () => {
      setTimeout(resizeWindowToFit, 100);
    });
</script>
</body>
</html>
